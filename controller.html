<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Michael Piotto Portfolio</title>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at 70% 50%, #020f1f, #14020f);
      color: #e8ebeb;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 80px 40px;
    }

    .title {
      font-size: 2.5rem;
      font-weight: 700;
      
      margin-bottom: 60px;
    }

    .images-row {
      display: flex;
      gap: 40px;
    }

    .image {
      width: 50%;
      height: auto;
      display: block;
      border-radius: 8px;
    }

    .description {
      font-size: 1rem;
      line-height: 1.6;
      color: #e8ebeb;
    }

    .description h3 {
      margin-top: 40px;
      margin-bottom: 10px;
      font-size: 1.3rem;
    }

    /* Key Features Title */
    .key-features-title {
      font-size: 2rem;
      font-weight: 700;
      margin-top: 60px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e8ebeb;
      padding-bottom: 10px;
    }

    /* Key Features Content */
    .key-features-content {
      display: flex;
      align-items: flex-start; /* align top of text and images */
      gap: 40px;
      margin-top: 20px;
      margin-bottom: 60px; /* extra space between features */
    }

    .feature-text {
      flex: 1;
      background-color: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 8px;
    }

    .feature-box-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 0 0 10px 0; /* remove top margin */
      color: #ffffff;
    }

    .feature-image {
      flex: 1;
      display: flex; /* for multiple images side by side */
      gap: 20px;
      align-items: flex-start; /* align tops of images */
    }

    .feature-image .image {
      width: 45%;
      height: auto; /* natural aspect ratio */
      border-radius: 8px;
      display: block;
    }

    .github-link {
      margin-left: 12px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #7fc8ff;
      text-decoration: none;

    }
    .github-link:hover {
    text-decoration: underline;
    }


  </style>
</head>

<body>
  <div class="page">
    <div class="title">
      Single Speed Chain Tensioner
    </div>

    <div class="images-row">
      <img src="RFcontroller\20260113_221647.jpg" alt="" class="image">
      <img src="RFcontroller\Screenshot 2026-01-13 223934.png" alt="" class="image">
    </div>

    <div class="description">
      <h3>What I Did:</h3>
      <p>I designed and built a remote controller for launching model rockets, including the full electronic system and a custom enclosure to house the circuit. The project involved integrating RF communication, control logic, and power electronics into a purpose-built device intended for safe remote launch of model rockets.</p>

      <h3>How I Did It:</h3>
      <p>I built the controller around 433 MHz RF transmitter and receiver modules. The transmitter is battery-powered and controlled by a Raspberry Pi Pico. An onboard speaker provides audible feedback to indicate when detonation data is being transmitted, using distinct beep patterns.

On the receiver side, a MOSFET driven by a 20 V battery is used to control ignition of the ignitors. Data transmitted between the RF modules consists of Manchester-encoded square-wave signals at 433 MHz.

I wrote MicroPython to control both Raspberry Pi Picos and implemented PIO assembly code to generate and decode the RF data stream. A specific pulse length, period, and transmission duration are required for the receiver to recognize a valid command and saturate the MOSFET, initiating ignition.

To reduce the risk of misfires, I incorporated diodes and pull-down resistors into the circuit. Both the transmitter and receiver electronics were housed in custom 3D-printed enclosures designed specifically for this system.
</p>

      <h3>Results:</h3>
      <p>The controller successfully transmitted launch commands to the receiver, reliably igniting the rocket motors without misfires. 
The remote successfully transmits commands wirelessly to a second Raspberry Pi. The controller achieves a range of approximately 100m, exceeding initial expectations.
</p>
    </div>

    <!-- Key Features Section -->
    <div class="key-features-title">
      Key Features
    </div>

    <!-- First Key Feature -->
    <div class="key-features-content">
      <div class="feature-text">
        <h4 class="feature-box-title">Speaker response</h4>
        <p>
          I previously made a timer based remote launcher where I used LED to indicate when the launch sequence had begun,
          however, they proved ineffective in bright sunlight. To address this, I integrated a speaker into the transmitter
          controller to provide audible feedback. This approach ensures the operator receives clear launch-status
          confirmation regardless of outside conditions. This system will make it safer ensuring the operator knows it is
          safe to approach the receiver module in the event of an issue.
        </p>
      </div>

      <div class="feature-image">
        <img src="RFcontroller/20260106_233916.jpg" alt="" class="image">
        <img src="" alt="" class="image">
      </div>
    </div>

    
    <div class="key-features-content">
      <div class="feature-text">
        
        
        

        <h4 class="feature-box-title">
          Decoding and sending data
        <a href="https://github.com/MICHAELpiotto/RF-contoller_micropyhton.git" target="_blank" class="github-link">GitHub</a>
        </h4>
        <p>Using the Raspberry Pi to generate and receive continuous data through GPIO is not possible because it only has a clock function that runs on the python OS. To address this, I used the Raspberry Pi Pico’s Programmable I/O (PIO) peripheral. PIO is an independent hardware state machine capable of running low-level assembly code to control GPIO pins.  
On the transmitter side, the PIO state machine reads encoded data from a FIFO buffer and drives a GPIO pin directly, without runtime interaction with Python. This signal feeds the 433 MHz transmitter, producing a square wave with a defined pulse width and period corresponding to the command being sent.
On the receiver side, a separate Raspberry Pi Pico and PIO state machine capture the incoming signal. The PIO measures pulse widths and periods in milliseconds and pushes this timing data into its FIFO. Specific pulse-period combinations are mapped to individual commands, such as the ignition signal.
The pio on the transmitter is run at 2000hz and the PIO on the receiver is running at the maximum 125Mhz, this is done so that the data sent into the receiver module is sampled at a higher rate to gather more accurate data.  
To put the data onto the RPI from the receiver and PIO, I sampled the FIFO using a loop. Conditional logic in Python then validates the received code and triggers the appropriate response.

            </p>
        </div>
      <div class="feature-image">
        <img src="RFcontroller\20260111_213736.jpg" alt="" class="image">
        <img src="RFcontroller\Screenshot 2026-01-12 102908.png" alt="" class="image">
      </div>
    </div>
  </div>
</body>
</html>
